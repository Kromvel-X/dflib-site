[#jdbc]
== Using Relational Databases

Relational databases are arguably the most important type of data stores out there. Also they happen to map
really well to DataFrames. DFLib provides advanced support for loading and saving DataFrames to RDBMS. It supports
transactions, auto-generation of certain SQL statements, merging of data on top of the existing data
("create-or-update"), building custom SQL for selects and updates. It knows how to treat different DB
"flavors" and does a number of other cool database-related things.

To start using all this, you need to import `dflib-jdbc` module:
[source,xml]
----
<dependency>
    <groupId>org.dflib</groupId>
    <artifactId>dflib-jdbc</artifactId>
</dependency>

<!-- Additionally, you need to import your JDBC driver -->
<dependency> ... </dependency>
----

=== JdbcConnector

Once the imports are set up, you'd use `Jdbc` class to create an instance of `JdbcConnector` that will be used for
all DB operations. You may already have a preconfigured `javax.sql.DataSource`, so the simplest way to create a
connector is to pass that DataSource to `Jdbc` factory method:

[source,java,indent=0]
----
include::${src-dir}/JdbcTest.java[tags=connectorDS]
----
Or you can specify the connection information directly:
[source,java,indent=0]
----
include::${src-dir}/JdbcTest.java[tags=connectorManual]
----

<1> (Optional) Driver name. Some drivers are not packaged in a JDBC-compliant manner, and require an explicit declaration.
<2> DB account username/password (not needed for our in-memory Derby example, but will definitely be required for a real database).

=== TableLoader / TableSaver
Once you have the connector, you can start reading and persisting `DataFrame` data. A `DataFrame` can map directly to
a single table (or a view) from the database. If that's the case, DFLib provides a set of rather straightforward
operations that do not require the user to write SQL (SQL is auto-generated by the framework):

[source,java,indent=0]
----
include::${src-dir}/JdbcTest.java[tags=tableLoader]
----
----
id name              salary
-- ----------------- --------
 1 Jerry Cosin       70000.0
 2 Juliana Walewski  85000.0
 3 Joan O'Hara       101000.0
----

Table loader provides a way to customize the load operation. It allows to select specific columns, set the maximum
number of rows to read, sample rows, and even specify fetch condition as another DataFrame. Some examples:
[source,java,indent=0]
----
include::${src-dir}/JdbcTest.java[tags=tableLoader_wOptions]
----
----
name        salary
----------- --------
Jerry Cosin 70000.0
Joan O'Hara 101000.0
----

What it doesn't require (unlike <<csv,CSV loader>>) is explicit column types, as the proper value types are inferred
from the database metadata.

Table saver allows to save DataFrame to a table. Column names in the DataFrame should match column names in the DB table:
[source,java,indent=0]
----
include::${src-dir}/JdbcTest.java[tags=tableSaver]
----

In this scenario table saver executes insert for each DataFrame row. But what if there is already an existing data
in the table? There are a few options the user has to overwrite or merge the data:

* Append the data (that's what we effectively did above).
* Delete all existing data before doing the insert.
* Merge the data by comparing DataFrame and DB table data on PK column(s) or an arbitrary set of columns. Insert missing
rows, update the existing rows. If the table has more columns than there are columns in the DataFrame, the data in those
extra columns is preserved.

Delete before insert example:
[source,java,indent=0]
----
include::${src-dir}/JdbcTest.java[tags=tableSaver_Delete]
----

Merge by PK example (PK columns are detected from DB metadata) :
[source,java,indent=0]
----
include::${src-dir}/JdbcTest.java[tags=tableSaver_Merge]
----

=== SqlLoader / SqlSaver

When you want to fetch data that spans more than one table, requires complex filtering conditions, or otherwise customize
the query, `TableLoader` can not be used. The alternative is to write your own SQL query and use `SqlLoader`:

[source,java,indent=0]
----
include::${src-dir}/JdbcTest.java[tags=sqlLoader]
----

----
name             city
---------------- ------
Joan O'Hara      Minsk
Joan O'Hara      Warsaw
Juliana Walewski London
----

`80000` value is hardcoded in the example above. We can make it a dynamic parameter, replacing it in the SQL with a
`?` sign and passing the value in the `.load(..)` method:

[source,java,indent=0]
----
include::${src-dir}/JdbcTest.java[tags=sqlLoader_params]
----

A few things to note here. The SQL String is written in a format of `java.sql.PreparedStatement`. So, `?` placeholders
denote dynamic parameters. Parameters are positional (each `?` position is matched with a value at that position in the
`load(..)` argument). Parameters can only be values, you can't pass pieces of SQL as parameters. This is a
`PreparedStatement` behavior that prevents SQL injection attacks.

Similarly, to save data with custom SQL, you would use `SqlSaver`:

[source,java,indent=0]
----
include::${src-dir}/JdbcTest.java[tags=sqlSaver]
----

SQL parameters should match a "row" in the `.save(..)` argument. If the argument is a `Series` or an `Object[]`,
it is treated as a single row of values, and will be bound to the prepared statement parameters by position. If the
argument is a `DataFrame`, the statement will be executed multiple times, once per each row.

DFLib code contains some JDBC-level
batching optimizations transparent to the user, that make the latter work faster, still the result you'd
observe would look as if you ran the SQL n times, where "n" is the height of the `DataFrame`.

